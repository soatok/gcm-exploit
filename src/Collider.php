<?php
declare(strict_types=1);
namespace Soatok\GCMCollider;

use ParagonIE\ConstantTime\Binary;
use Aws\Crypto\Polyfill\{
    ByteArray,
    Key
};
use Exception;

class Collider
{
    protected Key $alice;
    protected Key $bob;

    public function __construct()
    {
        $this->alice = new Key(random_bytes(32));
        $this->bob = new Key(random_bytes(32));
    }

    /**
     * @throws Exception
     */
    public function encrypt(Key $key, string $message, string $aad = '', ?string $iv = null): string
    {
        if (is_null($iv)) {
            $iv = random_bytes(12);
        }
        $tag = '';
        $c = openssl_encrypt(
            $message,
            'aes-256-gcm',
            $key->get(),
            OPENSSL_RAW_DATA | OPENSSL_NO_PADDING,
            $iv,
            $tag,
            $aad
        );
        return $iv . $c . $tag;
    }

    /**
     * @throws Exception
     */
    public function decrypt(Key $key, string $payload, string $aad = ''): string
    {
        $len = Binary::safeStrlen($payload);
        $iv = Binary::safeSubstr($payload, 0, 12);
        $c = Binary::safeSubstr($payload, 12, $len - 28);
        $tag = Binary::safeSubstr($payload, $len - 16, 16);

        $plaintext = openssl_decrypt(
            $c,
            'aes-256-gcm',
            $key->get(),
            OPENSSL_RAW_DATA | OPENSSL_NO_PADDING,
            $iv,
            $tag,
            $aad
        );
        if (!is_string($plaintext)) {
            throw new Exception('Invalid ciphertext or tag');
        }
        return $plaintext;
    }

    public function getAliceGF(string $nonce): GF128
    {
        return new GF128($this->alice, $nonce, 256);
    }

    public function getBobGF(string $nonce): GF128
    {
        return new GF128($this->bob, $nonce, 256);
    }

    /**
     * @throws Exception
     */
    public function generateUncool(string $plainA, string $plainB): string
    {
        $iv = random_bytes(12);
        //$iv = "DEFCON31Furs";

        // byte authKey1[] = authKey(key);
        // byte authKey2[] = authKey(key2);
        $authAlice = $this->getAliceGF($iv . "\x00\x00\x00\x01");
        $authBob = $this->getBobGF($iv . "\x00\x00\x00\x01");
        $authKeyAlice = $authAlice->getAuthKey();
        $authKeyBob = $authBob->getAuthKey();

        // byte tagBlock1[] = tagBlock(iv, key);
        // byte tagBlock2[] = tagBlock(iv, key2);
        $tagBlock1 = $authAlice->getTagBlock();
        $tagBlock2 = $authBob->getTagBlock();

        // byte ciphertext1[] = gctr(message1, iv, key);
        $output = openssl_encrypt(
            $plainA,
            'aes-256-ctr',
            $this->alice->get(),
            OPENSSL_RAW_DATA | OPENSSL_NO_PADDING,
            $iv . "\x00\x00\x00\x02"
        );
        $output .= openssl_encrypt(
            $plainB,
            'aes-256-ctr',
            $this->bob->get(),
            OPENSSL_RAW_DATA | OPENSSL_NO_PADDING,
            $iv . "\x00\x00\x00\x04"
        );
        $outlen = Binary::safeStrlen($output);
        if (($outlen & 0xf) !== 0) {
            throw new Exception('Combined message must be a multiple of 16 bytes');
        }

        $msgLenBits = (Binary::safeStrlen($plainA) + Binary::safeStrlen($plainB) + 16) << 3;
        // byte lengthBlock[] = lengthBlock(0, 32);
        // 80 * 8 = 640 -> 0x280 -> [2, 128]
        $lengthBlock = new ByteArray([
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0,
            ($msgLenBits >> 24) & 0xff,
            ($msgLenBits >> 16) & 0xff,
            ($msgLenBits >>  8) & 0xff,
            ($msgLenBits      ) & 0xff,
        ]);

        // byte rhs[] = add(tagBlock1, tagBlock2);
        $rhs = $tagBlock1->exclusiveOr($tagBlock2);

        // byte authKey1sq[] = mul(authKey1, authKey1);
        // byte authKey2sq[] = mul(authKey2, authKey2);
        $aliceSq = $authAlice->squareKey();
        $bobSq = $authBob->squareKey();

        // byte lhs[] = add(authKey1sq, authKey2sq);
        $lhs = $aliceSq->exclusiveOr($bobSq);

        // rhs = add(rhs, mul(lengthBlock, add(authKey1, authKey2)));
        $rhs = $rhs->exclusiveOr(
            $authAlice->multBlocks(
                $lengthBlock,
                $authKeyAlice->exclusiveOr($authKeyBob)
            )
        );

        // mul(inverse(lhs), rhs);
        $invLhs = $authAlice->inverse($lhs);

        // We know plainA and plainB are 32 bytes each
        $length = Binary::safeStrlen($output);
        $deg = ($length >> 4) + 1;
        for ($i = 0; $i < $length; $i += 16) {
            // H_i <- H1 ^ (mlen  2 - i) xor  H2 ^ (mlen  2 - i)
            $H_left = clone $authKeyAlice;
            $H_right = clone $authKeyBob;
            for ($j = 0; $j < $deg; ++$j) {
                $H_left = $authAlice->multBlocks($H_left, $authKeyAlice);
                $H_right = $authAlice->multBlocks($H_right, $authKeyBob);
            }
            --$deg;
            $H_i = $H_left->exclusiveOr($H_right);

            // C[i]
            $tmp = new ByteArray(
                Binary::safeSubstr($output, $i, 16)
            );
            // acc <- acc xor C[i] * H_i

            // rhs = add(rhs, mul(ciphertext1, add(authKey1cb, authKey2cb)));
            $rhs = $rhs->exclusiveOr(
                $authAlice->multBlocks($tmp, $H_i)
            );
        }
        $output .= $authAlice->multBlocks($rhs, $invLhs)->toString();

        $finalghash = $this->getAliceGF($iv . "\x00\x00\x00\x01");
        $finalghash->update(new ByteArray($output));
        $tag = $finalghash->finish(0, 80)->toString();


        $finalghash = $this->getBobGF($iv . "\x00\x00\x00\x01");
        $finalghash->update(new ByteArray($output));
        $tag2 = $finalghash->finish(0, 80)->toString();

        // $finalout = $finalghash->finish(0, 80);
        // $ghash = $finalout->exclusiveOr($tagBlock1);
        // $tag = $finalout->toString();
        return $iv . $output . $tag;
    }

    public function getKeyObjects(): array
    {
        return [
            'alice' => $this->alice,
            'bob' => $this->bob,
        ];
    }

    public function getKeys(): array
    {
        return [
            'alice' => bin2hex($this->alice->get()),
            'bob' => bin2hex($this->bob->get()),
        ];
    }
}
